#include <allegro.h>
#include <stdio.h>
#include <stdbool.h>

typedef enum {
    STATE_MENU,
    STATE_RULES,
    STATE_PLAYER_COUNT_SELECTION,
    STATE_CHARACTER_SELECTION,
    STATE_GAME
} GameState;

typedef enum {
    KNIGHT,
    NINJA,
    SAMURAI,
    MILITARY,
    CHARACTER_COUNT
} Character;

int selected_characters[4] = {-1, -1, -1, -1};
int current_player = 0;
int total_players = 2;
GameState game_state = STATE_MENU;
BITMAP *buffer;

int grid_positions[4][2] = {
    {0, 4}, {9, 4}, {0, 5}, {9, 5}
};
int cell_width = 80;
int cell_height = 70;

int player_moves_left[4] = {3, 3, 3, 3};
int countdown = 20;
int frame_counter = 0;

void draw_button(int x, int y, int w, int h, const char *label) {
    rectfill(buffer, x, y, x + w, y + h, makecol(100, 100, 100));
    rect(buffer, x, y, x + w, y + h, makecol(255, 255, 255));
    textout_centre_ex(buffer, font, label, x + w / 2, y + h / 3, makecol(255, 255, 255), -1);
}

void draw_custom_character(int x, int y, Character character) {
    switch (character) {
        case KNIGHT:   rectfill(buffer, x, y, x + 50, y + 50, makecol(0, 0, 255)); break;
        case NINJA:    rectfill(buffer, x, y, x + 50, y + 50, makecol(0, 0, 0)); break;
        case SAMURAI:  rectfill(buffer, x, y, x + 50, y + 50, makecol(255, 0, 0)); break;
        case MILITARY: rectfill(buffer, x, y, x + 50, y + 50, makecol(0, 255, 0)); break;
    }
}

void draw_grid() {
    for (int i = 0; i <= 10; ++i) {
        line(buffer, i * cell_width, 0, i * cell_width, 700, makecol(255, 255, 255));
        line(buffer, 0, i * cell_height, 800, i * cell_height, makecol(255, 255, 255));
    }
}

void draw_countdown(int time_left) {
    char countdown_text[50];
    sprintf(countdown_text, "Temps: %d s", time_left);
    textout_ex(buffer, font, countdown_text, SCREEN_W - 150, 30, makecol(255, 255, 255), -1);
}

bool is_cell_occupied(int x, int y) {
    for (int i = 0; i < total_players; ++i) {
        if (i != current_player && grid_positions[i][0] == x && grid_positions[i][1] == y) {
            return true;
        }
    }
    return false;
}

void show_menu() {
    clear_to_color(buffer, makecol(0, 0, 0));
    draw_button(300, 200, 200, 50, "Commencer une partie");
    draw_button(300, 300, 200, 50, "Afficher les règles");

    if (mouse_b & 1) {
        if (mouse_x >= 300 && mouse_x <= 500) {
            if (mouse_y >= 200 && mouse_y <= 250) {
                game_state = STATE_PLAYER_COUNT_SELECTION;
                rest(200);
            } else if (mouse_y >= 300 && mouse_y <= 350) {
                game_state = STATE_RULES;
                rest(200);
            }
        }
    }
}

void show_player_count_selection() {
    clear_to_color(buffer, makecol(0, 0, 0));
    textout_centre_ex(buffer, font, "Choisissez le nombre de joueurs", SCREEN_W / 2, 100, makecol(255, 255, 255), -1);
    draw_button(250, 200, 100, 50, "2 joueurs");
    draw_button(350, 200, 100, 50, "3 joueurs");
    draw_button(450, 200, 100, 50, "4 joueurs");

    if (mouse_b & 1) {
        if (mouse_y >= 200 && mouse_y <= 250) {
            if (mouse_x >= 250 && mouse_x <= 350) {
                total_players = 2;
            } else if (mouse_x >= 350 && mouse_x <= 450) {
                total_players = 3;
            } else if (mouse_x >= 450 && mouse_x <= 550) {
                total_players = 4;
            } else {
                return;
            }

            for (int i = 0; i < 4; i++) {
                selected_characters[i] = -1;
                player_moves_left[i] = 3;
                grid_positions[i][0] = (i % 2 == 0) ? 0 : 9;
                grid_positions[i][1] = 4 + (i / 2);
            }
            current_player = 0;
            game_state = STATE_CHARACTER_SELECTION;
            rest(200);
        }
    }
}

void show_rules() {
    clear_to_color(buffer, makecol(50, 50, 50));
    textout_ex(buffer, font, "Regles :", 50, 50, makecol(255, 255, 255), -1);
    textout_ex(buffer, font, "- Cliquez pour vous déplacer.", 50, 80, makecol(255, 255, 255), -1);
    textout_ex(buffer, font, "- 3 déplacements ou 20 sec/tour.", 50, 100, makecol(255, 255, 255), -1);
    draw_button(10, 550, 200, 40, "Retour au menu");

    if (mouse_b & 1 && mouse_x >= 10 && mouse_x <= 210 && mouse_y >= 550 && mouse_y <= 590) {
        game_state = STATE_MENU;
        rest(200);
    }
}

void show_character_selection() {
    clear_to_color(buffer, makecol(30, 30, 30));
    char buf[100];
    sprintf(buf, "Joueur %d: Choisissez un personnage", current_player + 1);
    textout_centre_ex(buffer, font, buf, SCREEN_W / 2, 50, makecol(255, 255, 255), -1);

    int start_x = 100;
    for (int i = 0; i < CHARACTER_COUNT; ++i) {
        draw_custom_character(start_x + i * 100, 150, i);
        rect(buffer, start_x + i * 100, 150, start_x + i * 100 + 50, 200, makecol(255, 255, 255));
    }

    draw_button(10, 550, 200, 40, "Retour au menu");

    if (mouse_b & 1) {
        if (mouse_x >= 10 && mouse_x <= 210 && mouse_y >= 550 && mouse_y <= 590) {
            game_state = STATE_MENU;
            rest(200);
            return;
        }

        for (int i = 0; i < CHARACTER_COUNT; ++i) {
            int x = start_x + i * 100;
            if (mouse_x >= x && mouse_x <= x + 50 && mouse_y >= 150 && mouse_y <= 200) {
                selected_characters[current_player] = i;
                current_player++;
                rest(200);
                if (current_player >= total_players) {
                    game_state = STATE_GAME;
                    current_player = 0;
                    countdown = 20;
                }
                break;
            }
        }
    }
}

void next_turn() {
    current_player = (current_player + 1) % total_players;
    player_moves_left[current_player] = 3;
    countdown = 20;
}

void handle_movement_buttons(int x, int y, int w, int h, const char* direction) {
    if (mouse_b & 1 && mouse_x >= x && mouse_x <= x + w && mouse_y >= y && mouse_y <= y + h) {
        int new_x = grid_positions[current_player][0];
        int new_y = grid_positions[current_player][1];

        if (player_moves_left[current_player] > 0) {
            if (strcmp(direction, "Haut") == 0 && new_y > 0) new_y--;
            else if (strcmp(direction, "Bas") == 0 && new_y < 9) new_y++;
            else if (strcmp(direction, "Gauche") == 0 && new_x > 0) new_x--;
            else if (strcmp(direction, "Droite") == 0 && new_x < 9) new_x++;

            if (!is_cell_occupied(new_x, new_y)) {
                grid_positions[current_player][0] = new_x;
                grid_positions[current_player][1] = new_y;
                player_moves_left[current_player]--;
            }

            rest(200);
        }
    }
}

void show_game() {
    clear_to_color(buffer, makecol(0, 100, 100));
    draw_grid();
    textout_ex(buffer, font, "Partie en cours...", 300, 20, makecol(255, 255, 255), -1);

    for (int i = 0; i < total_players; ++i) {
        int px = grid_positions[i][0] * cell_width;
        int py = grid_positions[i][1] * cell_height;
        draw_custom_character(px + 15, py + 10, selected_characters[i]);
    }

    draw_countdown(countdown);

    draw_button(300, 500, 100, 40, "Haut");
    draw_button(300, 600, 100, 40, "Bas");
    draw_button(200, 550, 100, 40, "Gauche");
    draw_button(400, 550, 100, 40, "Droite");
    draw_button(10, 650, 200, 40, "Retour au menu");

    handle_movement_buttons(300, 500, 100, 40, "Haut");
    handle_movement_buttons(300, 600, 100, 40, "Bas");
    handle_movement_buttons(200, 550, 100, 40, "Gauche");
    handle_movement_buttons(400, 550, 100, 40, "Droite");

    if (mouse_b & 1 && mouse_x >= 10 && mouse_x <= 210 && mouse_y >= 650 && mouse_y <= 690) {
        game_state = STATE_MENU;
        rest(200);
    }

    if (++frame_counter >= 50) {
        countdown--;
        frame_counter = 0;
    }

    if (countdown <= 0 || player_moves_left[current_player] <= 0) {
        next_turn();
    }
}

int main() {
    allegro_init();
    install_keyboard();
    install_mouse();
    set_color_depth(32);
    set_gfx_mode(GFX_AUTODETECT_WINDOWED, 800, 700, 0, 0);
    show_mouse(screen);

    buffer = create_bitmap(800, 700);

    while (!key[KEY_ESC]) {
        switch (game_state) {
            case STATE_MENU: show_menu(); break;
            case STATE_RULES: show_rules(); break;
            case STATE_PLAYER_COUNT_SELECTION: show_player_count_selection(); break;
            case STATE_CHARACTER_SELECTION: show_character_selection(); break;
            case STATE_GAME: show_game(); break;
        }

        blit(buffer, screen, 0, 0, 0, 0, 800, 700);
        clear_bitmap(buffer);
        rest(20);
    }

    destroy_bitmap(buffer);
    return 0;
}
END_OF_MAIN();


