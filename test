#include <allegro.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define GRID_SIZE 10
#define CELL_SIZE 60
#define MAX_PLAYERS 4
#define MAX_OBSTACLES 2

typedef enum {
    STATE_MENU,
    STATE_RULES,
    STATE_PLAYER_COUNT_SELECTION,
    STATE_CHARACTER_SELECTION,
    STATE_GAME
} GameState;

typedef enum {
    KNIGHT,
    NINJA,
    SAMURAI,
    MILITARY,
    CHARACTER_COUNT
} Character;

int selected_characters[MAX_PLAYERS] = {-1, -1, -1, -1};
int current_player = 0;
int total_players = 2;
GameState game_state = STATE_MENU;
BITMAP *buffer;

int player_grid_positions[MAX_PLAYERS][2];
int player_moves_left[MAX_PLAYERS] = {3, 3, 3, 3};
int countdown = 20;
int frame_counter = 0;

int grid[GRID_SIZE][GRID_SIZE] = {0};

void draw_button(int x, int y, int w, int h, const char *label) {
    rectfill(buffer, x, y, x + w, y + h, makecol(100, 100, 100));
    rect(buffer, x, y, x + w, y + h, makecol(255, 255, 255));
    textout_centre_ex(buffer, font, label, x + w / 2, y + h / 3, makecol(255, 255, 255), -1);
}

void draw_custom_character(int x, int y, Character character) {
    switch (character) {
        case KNIGHT:   rectfill(buffer, x, y, x + CELL_SIZE, y + CELL_SIZE, makecol(0, 0, 255)); break;
        case NINJA:    rectfill(buffer, x, y, x + CELL_SIZE, y + CELL_SIZE, makecol(0, 0, 0)); break;
        case SAMURAI:  rectfill(buffer, x, y, x + CELL_SIZE, y + CELL_SIZE, makecol(255, 0, 0)); break;
        case MILITARY: rectfill(buffer, x, y, x + CELL_SIZE, y + CELL_SIZE, makecol(0, 255, 0)); break;
    }
}

void draw_countdown(int time_left) {
    char countdown_text[50];
    sprintf(countdown_text, "Temps: %d s", time_left);
    textout_ex(buffer, font, countdown_text, SCREEN_W - 150, 30, makecol(255, 255, 255), -1);
}

void draw_grid() {
    for (int y = 0; y < GRID_SIZE; y++) {
        for (int x = 0; x < GRID_SIZE; x++) {
            int px = x * CELL_SIZE;
            int py = y * CELL_SIZE;
            rect(buffer, px, py, px + CELL_SIZE, py + CELL_SIZE, makecol(255, 255, 255));
            if (grid[y][x] == 9) {
                line(buffer, px, py, px + CELL_SIZE, py + CELL_SIZE, makecol(255, 0, 0));
                line(buffer, px + CELL_SIZE, py, px, py + CELL_SIZE, makecol(255, 0, 0));
            }
        }
    }
}

int is_valid_cell(int x, int y) {
    return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && grid[y][x] == 0;
}

void highlight_accessible_cells(int x, int y) {
    int dx[] = {0, 0, -1, 1};
    int dy[] = {-1, 1, 0, 0};

    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (is_valid_cell(nx, ny)) {
            rectfill(buffer, nx * CELL_SIZE, ny * CELL_SIZE, (nx + 1) * CELL_SIZE, (ny + 1) * CELL_SIZE, makecol(255, 255, 100));
        }
    }
}

void next_turn() {
    current_player = (current_player + 1) % total_players;
    player_moves_left[current_player] = 3;
    countdown = 20;
}

void show_game() {
    clear_to_color(buffer, makecol(0, 100, 100));
    textout_ex(buffer, font, "Partie en cours...", 300, 20, makecol(255, 255, 255), -1);
    draw_grid();

    for (int i = 0; i < total_players; ++i) {
        int px = player_grid_positions[i][0];
        int py = player_grid_positions[i][1];
        draw_custom_character(px * CELL_SIZE, py * CELL_SIZE, selected_characters[i]);
    }

    int cx = player_grid_positions[current_player][0];
    int cy = player_grid_positions[current_player][1];
    highlight_accessible_cells(cx, cy);

    draw_countdown(countdown);
    draw_button(10, 650, 200, 40, "Retour au menu");

    if (mouse_b & 1 && mouse_x >= 10 && mouse_x <= 210 && mouse_y >= 650 && mouse_y <= 690) {
        game_state = STATE_MENU;
        rest(200);
    }

    if (mouse_b & 1 && player_moves_left[current_player] > 0) {
        int gx = mouse_x / CELL_SIZE;
        int gy = mouse_y / CELL_SIZE;

        if ((abs(gx - cx) == 1 && gy == cy) || (abs(gy - cy) == 1 && gx == cx)) {
            if (is_valid_cell(gx, gy)) {
                grid[cy][cx] = 0;
                player_grid_positions[current_player][0] = gx;
                player_grid_positions[current_player][1] = gy;
                grid[gy][gx] = current_player + 1;
                player_moves_left[current_player]--;
                rest(200);
            }
        }
    }

    if (++frame_counter >= 50) {
        countdown--;
        frame_counter = 0;
    }

    if (countdown <= 0 || player_moves_left[current_player] <= 0) {
        next_turn();
    }
}

void place_players_and_obstacles() {
    srand(time(NULL));
    int placed_players = 0, placed_obstacles = 0;

    for (int i = 0; i < MAX_PLAYERS; i++) {
        player_grid_positions[i][0] = -1;
        player_grid_positions[i][1] = -1;
    }

    while (placed_players < total_players) {
        int x = rand() % GRID_SIZE;
        int y = rand() % GRID_SIZE;
        if (grid[y][x] == 0) {
            grid[y][x] = placed_players + 1;
            player_grid_positions[placed_players][0] = x;
            player_grid_positions[placed_players][1] = y;
            placed_players++;
        }
    }

    while (placed_obstacles < MAX_OBSTACLES) {
        int x = rand() % GRID_SIZE;
        int y = rand() % GRID_SIZE;
        if (grid[y][x] == 0) {
            grid[y][x] = 9;
            placed_obstacles++;
        }
    }
}

void show_menu() {
    clear_to_color(buffer, makecol(0, 0, 0));
    draw_button(300, 200, 200, 50, "Commencer une partie");
    draw_button(300, 300, 200, 50, "Afficher les règles");

    if (mouse_b & 1) {
        if (mouse_x >= 300 && mouse_x <= 500) {
            if (mouse_y >= 200 && mouse_y <= 250) {
                game_state = STATE_PLAYER_COUNT_SELECTION;
                rest(200);
            } else if (mouse_y >= 300 && mouse_y <= 350) {
                game_state = STATE_RULES;
                rest(200);
            }
        }
    }
}

void show_rules() {
    clear_to_color(buffer, makecol(50, 50, 50));
    textout_ex(buffer, font, "Règles :", 50, 50, makecol(255, 255, 255), -1);
    textout_ex(buffer, font, "- Cliquez sur une case adjacente pour vous déplacer.", 50, 80, makecol(255, 255, 255), -1);
    draw_button(10, 550, 200, 40, "Retour au menu");

    if (mouse_b & 1 && mouse_x >= 10 && mouse_x <= 210 && mouse_y >= 550 && mouse_y <= 590) {
        game_state = STATE_MENU;
        rest(200);
    }
}

void show_player_count_selection() {
    clear_to_color(buffer, makecol(0, 0, 0));
    textout_centre_ex(buffer, font, "Choisissez le nombre de joueurs", SCREEN_W / 2, 100, makecol(255, 255, 255), -1);
    draw_button(250, 200, 100, 50, "2 joueurs");
    draw_button(350, 200, 100, 50, "3 joueurs");
    draw_button(450, 200, 100, 50, "4 joueurs");

    if (mouse_b & 1) {
        if (mouse_y >= 200 && mouse_y <= 250) {
            if (mouse_x >= 250 && mouse_x <= 350) total_players = 2;
            else if (mouse_x >= 350 && mouse_x <= 450) total_players = 3;
            else if (mouse_x >= 450 && mouse_x <= 550) total_players = 4;
            else return;

            for (int i = 0; i < MAX_PLAYERS; i++) selected_characters[i] = -1;
            current_player = 0;
            game_state = STATE_CHARACTER_SELECTION;
            rest(200);
        }
    }
}

void show_character_selection() {
    clear_to_color(buffer, makecol(30, 30, 30));
    char buf[100];
    sprintf(buf, "Joueur %d: Choisissez un personnage", current_player + 1);
    textout_centre_ex(buffer, font, buf, SCREEN_W / 2, 50, makecol(255, 255, 255), -1);

    int start_x = 100;
    for (int i = 0; i < CHARACTER_COUNT; ++i) {
        draw_custom_character(start_x + i * 100, 150, i);
        rect(buffer, start_x + i * 100, 150, start_x + i * 100 + CELL_SIZE, 200, makecol(255, 255, 255));
    }

    draw_button(10, 550, 200, 40, "Retour au menu");

    if (mouse_b & 1) {
        if (mouse_x >= 10 && mouse_x <= 210 && mouse_y >= 550 && mouse_y <= 590) {
            game_state = STATE_MENU;
            rest(200);
            return;
        }

        for (int i = 0; i < CHARACTER_COUNT; ++i) {
            int x = start_x + i * 100;
            if (mouse_x >= x && mouse_x <= x + CELL_SIZE && mouse_y >= 150 && mouse_y <= 200) {
                selected_characters[current_player] = i;
                current_player++;
                rest(200);
                if (current_player >= total_players) {
                    game_state = STATE_GAME;
                    current_player = 0;
                    countdown = 20;
                    place_players_and_obstacles();
                }
                break;
            }
        }
    }
}

int main() {
    allegro_init();
    install_keyboard();
    install_mouse();
    set_color_depth(32);
    set_gfx_mode(GFX_AUTODETECT_WINDOWED, 800, 700, 0, 0);
    show_mouse(screen);

    buffer = create_bitmap(800, 700);

    while (!key[KEY_ESC]) {
        switch (game_state) {
            case STATE_MENU: show_menu(); break;
            case STATE_RULES: show_rules(); break;
            case STATE_PLAYER_COUNT_SELECTION: show_player_count_selection(); break;
            case STATE_CHARACTER_SELECTION: show_character_selection(); break;
            case STATE_GAME: show_game(); break;
        }

        blit(buffer, screen, 0, 0, 0, 0, 800, 700);
        clear_bitmap(buffer);
        rest(20);
    }

    destroy_bitmap(buffer);
    return 0;
}
END_OF_MAIN();



